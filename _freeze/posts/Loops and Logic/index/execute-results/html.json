{
  "hash": "e2c7e395b85c82ddfdf4a0003be00d71",
  "result": {
    "markdown": "---\ntitle: \"Logic\"\nauthor: \"Noon Elsaeyed\"\ndate: \"2023-03-01\"\ncategories: [skills,tips]\n---\n\n\n### Loops and Logic\n\nLogic statements are used to compare two things, or two sets of things. The output of comparison is a TRUE or FALSE statment. If many things are being compared at once, the output could be many TRUE or FALSE statements for each comparison\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 == 1 # is 1 equal to 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n1 == 2 # is 1 equal to 2?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n\nc(1, 2, 3) == c(2, 1, 3) # compares each element with each element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE FALSE  TRUE\n1 == c(2, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE  TRUE FALSE\n```\n:::\n\n\n### Not Equal To (!=)\n\n::: {.cell}\n\n```{.r .cell-code}\n1 != 1 # is 1 equal to 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n1 != 2 # is 1 equal to 2?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n\nc(1, 2, 3) != c(2, 1, 3) # compares each element with each element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE  TRUE FALSE\n1 != c(2, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE FALSE  TRUE\n```\n:::\n\n\n### Greater Than and Less Than\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 > 1 # is 1 greater than 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n5 > 1 # is 5 greater than 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n3 < 2 # is 3 less than 2?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n3 < 1 # is 3 less than 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n\nc(1, 2, 3) > c(2, 1, 3) # ask the question element by element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE  TRUE FALSE\nc(1, 2, 3) < c(2, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE FALSE FALSE\n\n2 > c(1, 2, 3) # is greater than each of the numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE FALSE FALSE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 >= 1 # is 1 greater than 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n5 >= 1 # is 5 greater than 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n3 <= 2 # is 3 less than 2?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n3 <= 1 # is 3 less than 1?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n\nc(1, 2, 3) >= c(2, 1, 3) # ask the question element by element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE  TRUE  TRUE\nc(1, 2, 3) <= c(2, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE FALSE  TRUE\n\n2 >= c(1, 2, 3) # is greater than each of the numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1]  TRUE  TRUE FALSE\n```\n:::\n\n\n### AND\n\nThe ampersand & is used for AND, which allows use to evaluate whether two or more properties are all TRUE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# is 16 divisible by 4 AND 8\n16 %% 4 == 0 & 16 %% 8 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n\n# is 16 divisible by 4 AND 3\n16 %% 4 == 0 & 16 %% 3 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE\n\n# is 16 divisible by 8 and 4 and 2\n16 %% 4 == 0 & 16 %% 8 == 0 & 16 %% 2 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n```\n:::\n\n\n### OR\n\nThe | is used for OR, which allows use to evaluate at least one of the properties is TRUE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# is 16 divisible by 4 OR 8\n16 %% 4 == 0 | 16 %% 8 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n\n# is 16 divisible by 4 OR 3\n# it is divisible by 4, so the answer is TRUE\n# because at least one of the comparisons is TRUE\n16 %% 4 == 0 | 16 %% 3 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE\n```\n:::\n\n\n### True False\n\nWhen R returns values as TRUE or FALSE, it return a logical variable. It also treats TRUE as a 1, and FALSE as a 0. In the example below we see it is possible sum up a logical variable with multiple TRUE and FALSE entries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) == c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] TRUE TRUE TRUE\nsum(c(1, 2, 3) == c(1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n#> [1] 3\n\nc(1, 2, 3) == c(2, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#> [1] FALSE FALSE  TRUE\nsum(c(1, 2, 3) == c(2, 1, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n```\n:::\n\n\n### If Else\n\nA roller-coaster operator checks if people are taller than a line to see if they can ride the coaster. This is an IF ELSE control structure. IF the person is taller than the line, then they can go on the ride; ELSE (otherwise) the person can not go on the ride.\n\nIn other words, IF the situation is X, then do something; ELSE (if the situation is not X), then do something different.\n\nIF and ELSE statements let us specify the conditions when specific actions are taken. Generally, IF and ELSE statements are used inside loops (for, or while, or repeat loops), because at each step or iteration of the loop, we want to check something, and then do something.\n\nConsider this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1 # define a to be a 1\nif (a == 1) {\n  print(a) # this is what happens if a==1\n} else {\n  print(\"A is not 1\") # this is what happens if a is not 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n\n\na <- 2 # define a to be a 1\nif (a == 1) {\n  print(a) # this is what happens if a==1\n} else {\n  print(\"A is not 1\") # this is what happens if a is not 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A is not 1\"\n```\n:::\n\n```{.r .cell-code}\n#> [1] \"A is not 1\"\n```\n:::\n\n\nNormally Found (if and else) in a Loop like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 0, 1, 0, 0, 0, 1) # make a variable contain 1s and 0s\n\n# write a loop to check each element in the variable\n# and do different things depending on the element\n\nfor (i in a) {\n  if (i == 1) {\n    print(\"I'm a 1\") # what to do when i is 1\n  } else {\n    print(\"I'm not a 1\") # what to do when i is not 1\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I'm a 1\"\n[1] \"I'm not a 1\"\n[1] \"I'm a 1\"\n[1] \"I'm not a 1\"\n[1] \"I'm not a 1\"\n[1] \"I'm not a 1\"\n[1] \"I'm a 1\"\n```\n:::\n\n```{.r .cell-code}\n#> [1] \"I'm a 1\"\n#> [1] \"I'm not a 1\"\n#> [1] \"I'm a 1\"\n#> [1] \"I'm not a 1\"\n#> [1] \"I'm not a 1\"\n#> [1] \"I'm not a 1\"\n#> [1] \"I'm a 1\"\n```\n:::\n\n\nWe can have multiple conditions in our if statements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, 3, 1, 2, 0, 1) # make a variable contain 1s and 0s\n\n# write a loop to check each element in the variable\n# and do different things depending on the element\n\nfor (i in a) {\n  if (i == 1) {\n    print(\"I'm a 1\") # what to do when i is 1\n  } else if (i == 2) {\n    print(\"I'm a 2\") # what to do when i is 2\n  } else if (i == 3) {\n    print(\"I'm a 3\") # what to do when i is 3\n  } else {\n    print(\"I'm not any of the above\") #what to do when none are true\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I'm a 1\"\n[1] \"I'm a 2\"\n[1] \"I'm a 3\"\n[1] \"I'm a 1\"\n[1] \"I'm a 2\"\n[1] \"I'm not any of the above\"\n[1] \"I'm a 1\"\n```\n:::\n\n```{.r .cell-code}\n#> [1] \"I'm a 1\"\n#> [1] \"I'm a 2\"\n#> [1] \"I'm a 3\"\n#> [1] \"I'm a 1\"\n#> [1] \"I'm a 2\"\n#> [1] \"I'm not any of the above\"\n#> [1] \"I'm a 1\"\n```\n:::\n\n### Loops\n\nfor(){} for(loop control){do something each iteration}\n\n\nfor(iterator in vector) {\n  #do something\n\n\nLoop control is defined in between the parentheses. The name of the iterator is placed on the left of in(can be assigned any name you want, does not need to be declared in advance). During the execution of the loop, the iterator takes on the values inside the vector which is placed on the right side of in. Specifically, the following is happening.\n\nLoop steps: 1. iterator <- vector[1] 2. iterator <- vector[2] 3. iterator <- vector[3] 4. etc.\n\nThe loop will automatically stop once it reaches the last item in the vector. The loop can be stopped before that using the break command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a loop do something 5 times\n# i is the iterator\n# 1:5 creates a vector with 5 numbers in it, 1, 2, 3, 4, 5\n# the loop will run 5 times, because there are five things to assign to i\nfor(i in 1:5) {\n  print(\"hello\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello\"\n[1] \"hello\"\n[1] \"hello\"\n[1] \"hello\"\n[1] \"hello\"\n```\n:::\n\n```{.r .cell-code}\n#> [1] \"hello\"\n#> [1] \"hello\"\n#> [1] \"hello\"\n#> [1] \"hello\"\n#> [1] \"hello\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# show the value of i each step of the loop\nfor(i in 1:5) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the vector to loop over in advance\nx <- 1:5\nfor (i in x) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reminder that i becomes the next value in the vector\n# your vector can have any order \nmy_sequence <- c(1, 5, 2, 3, 4)\nfor (i in my_sequence) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 5\n[1] 2\n[1] 3\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 5\n#> [1] 2\n#> [1] 3\n#> [1] 4\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# index vector does not need to be numbers\nmy_things <- c(\"A\", \"B\", \"C\", \"D\")\nfor (i in my_things) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\"\n[1] \"B\"\n[1] \"C\"\n[1] \"D\"\n```\n:::\n\n```{.r .cell-code}\n#> [1] \"A\"\n#> [1] \"B\"\n#> [1] \"C\"\n#> [1] \"D\"\n```\n:::\n\n\n### Breaking Loops\n\nbreak stops a loop. Used with logical statements to define the conditions necessary to cause the break.\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:10) {\n  if (i < 5) {\n    print(i)\n  } else{\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n```\n:::\n\n\n### While Loops\n\nWhile loops run until a logical condition is met. Here there is no iterator, just a logic statement that needs to be met.\n\nThis one prints i while i is less than 6. As soon as i becomes “not less than 6”, then the loop stops. Critically, inside the loop, the value of i increases each iteration.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1 # create an variable\nwhile (i < 6) {\n  print(i)\n  i = i + 1 #add one eachs step of the loop\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n### Repeat Loops\n\nUntil a condition is met\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\nrepeat {\n  i <- i + 1\n  print(i)\n  if (i == 5) {\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}